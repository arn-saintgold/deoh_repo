## This function allows us to specify which facet to annotate
annotation_custom2 <- function (grob, xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf, data) {
layer(data = data, stat = StatIdentity, position = PositionIdentity,
geom = ggplot2:::GeomCustomAnn,
inherit.aes = F, params = list(grob = grob,
xmin = xmin, xmax = xmax,
ymin = ymin, ymax = ymax))
}
# create insets for barchart
setDT(pie_data)
pie_data[,Emotion := factor(Emotion, levels = str_to_title(emotions))]
insets <- pie_data %>%
split(f = .$Emotion)%>%
purrr::map(~annotation_custom2(
grob = ggplotGrob(get_pie_emo_from_df(., text_size = 4)),
data = data.frame(Emotion=unique(.$Emotion)),
ymin = .51, ymax=.87)
)
# insert insets
rainbow_pie <- much_color +
theme(panel.spacing = unit(0, "lines"),
strip.background = element_rect(fill=NA, color = 'black', linewidth = 1))+
geom_hline(yintercept=.50,
color = "black", linewidth=.5)+
insets
ggsave(plot_path, plot=rainbow_pie, device = 'pdf', width = WIDTH, height = HEIGHT, units = 'in', dpi = 600, )
rainbow_pie
emo_in_commnets[,.N]
emo_in_comments[,.N]
source('packages_n_global_variables.R')
emo_csv <- fread(emo_csv_path)
emotions <- emotions[c(2,5,8,3,7,6,1,4)]
emo_in_comments <- emo_csv[emotiveness>0, .(counts=colSums(.SD), negativeCounts = .N-colSums(.SD), emo=names(.SD)), by=Is_questionable, .SDcols = paste0('has_',emotions)]
chi_cram <- data.frame()
for (e in emo_in_comments[,emo]%>%unique()){
message(e)
curr_emo <- emo_in_comments[emo == e]
M<-curr_emo[,.(Is_questionable,counts, negativeCounts)]%>%t()
colnames(M)<-M[1,]
Mn<-matrix(as.numeric(M[2:3,]),ncol = 2)
rownames(Mn)<-rownames(M[2:3,])
colnames(Mn)<-colnames(M)
chisq.result <- chisq.test(Mn)
print(chisq.result)
print(confintr::ci_cramersv(chisq.result))
my_cramer<-confintr::ci_cramersv(chisq.result)
chi_cram_row <- c(e%>%str_remove('has_')%>%str_to_title(), round(chisq.result$statistic,digit=2), chisq.result$p.value, round(my_cramer$estimate,3), round(my_cramer$interval[1],3), round(my_cramer$interval[2],3))
chi_cram <- rbind(chi_cram,chi_cram_row)
}
names(chi_cram)<-c('Emotion', '$\\chi^2$', 'p.value', "Cramer's V", "Cramer's V low", "Cramer's V high" )
print.xtable(xtable(chi_cram), row.names = F,include.rownames=FALSE)
emo_in_comments[,.N]
emo_csv[,.N]
emo_in_comments
emo_csv[emotiveness>0,.N]
chisq.result$statistic
chisq.result$parameter
chisq.result$statistic
chisq.result
chisq.result$method
263823+411094
263823+23677+411094+36677
8428+51926+88675+586242
source('packages_n_global_variables.R')
emo_csv <- fread(emo_csv_path)
my_pivot = emo_csv[,.(N = .N), by=.(Is_questionable, Label)]
dcast(my_pivot, Label ~ Is_questionable, value.var = c("N") )%>%xtable()
data<- dcast(my_pivot, Label ~ Is_questionable , value.var = c("N") )
data
# Compute percentages
data[, Qfraction := Questionable/sum(Questionable)]
data[, Rfraction := Reliable/sum(Reliable)]
# Compute the cumulative percentages (top of each rectangle)
data[,Qymax := cumsum(Qfraction)]
data[,Rymax := cumsum(Rfraction)]
# Compute the bottom of each rectangle
data[, Qymin:= c(0, head(Qymax, n=-1))]#$ymin = c(0, head(data$ymax, n=-1))
data[, Rymin:= c(0, head(Rymax, n=-1))]
# Compute label position
data[, QlabelPosition:=(Qymax + Qymin) / 2 ]
data[, RlabelPosition:=(Rymax + Rymin) / 2 ]
# Compute a good label
data[, Qlabel:= paste0(100*round(Qfraction, 4), "%" )]
data[, Rlabel:= paste0(100*round(Rfraction, 4), "%" )]
emo_csv
emo_csv <- fread(emo_csv_path)
source('packages_n_global_variables.R')
emotions <- emotions[c(2,5,8,3,7,6,1,4)]
emo_in_comments
emo_csv[,has_emotion]%>%head()
emo_csv[,counts=colSums(has_emotion), negativeCounts = .N-colSums(has_emotion)]
emo_csv[,.(counts=colSums(has_emotion*1), negativeCounts = .N-colSums(has_emotion*1))]
emo_csv[,.(counts=sum(has_emotion*1), negativeCounts = .N-sum(has_emotion*1))]
emo_csv[,.(counts=sum(has_emotion*1), negativeCounts = .N-sum(has_emotion*1)), by = is_questionable]
emo_csv[,.(counts=sum(has_emotion*1), negativeCounts = .N-sum(has_emotion*1)), by = Is_questionable]
R_Q_emotion_independence_table <- emo_csv[,.(counts=sum(has_emotion*1), negativeCounts = .N-sum(has_emotion*1)), by = Is_questionable]
chisq.result <- chisq.test(q_r_has_emo)
q_r_has_emo <- emo_csv[,.(
counts=sum(has_emotion*1),
negativeCounts = .N-sum(has_emotion*1)
),
by = Is_questionable]
chisq.result <- chisq.test(q_r_has_emo)
q_r_has_emo <- emo_csv[,.(
counts=sum(has_emotion*1),
negativeCounts = .N-sum(has_emotion*1)
),
by = Is_questionable]
M<-q_r_has_emo[,.(Is_questionable,counts, negativeCounts)]%>%t()
q_r_has_emo
M
colnames(M)<-M[1,]
Mn<-matrix(as.numeric(M[2:3,]),ncol = 2)
rownames(Mn)<-rownames(M[2:3,])
colnames(Mn)<-colnames(M)
Mn
chisq.result <- chisq.test(q_r_has_emo)
chisq.result
chisq.result <- chisq.test(Mn)
chisq.result
print(chisq.result)
print(confintr::ci_cramersv(chisq.result))
library(tidyverse)
library(data.table)
library(ggplot2)
setwd("~/Documents/project_transfer/yt_analyses/bootstrap_lollipop_to_cluster")
bs <- fread("bootstrap_sample.csv")
trust<-bs[emo1=='trust']
original <- bs[is_not_bootstrapped==T]
bootstrapped <- bs[is_not_bootstrapped==F]
emotions <- c("anger", "trust", "surprise", "disgust", "joy" ,"sadness", "fear", "anticipation")
emotions<-emotions[c(2,5,8,3,7,1,6,4)]
my_cols = paste0("has_", emotions)
bootstrapped[emo1=='trust',lapply(.SD, median), by=is_questionable, .SDcols = paste0("has_",emotions)]
bootstrapped[emo1=='trust',lapply(.SD,function(x) quantile(x,probs = .75)), by=is_questionable, .SDcols = paste0("has_",emotions)]
setwd("~/Documents/project_transfer/yt_analyses/bootstrap_lollipop_to_cluster")
emotions <-c("anger", "anticipation", "disgust", "fear", "joy", "trust", "sadness","surprise")
emotions <- emotions[c(6, 5, 2, 8, 7, 4, 1, 3)]
bs_trip_res <- fread("less_bootstrap_sample_triplet.csv")
trip_original <- bs_trip_res[is_not_bootstrapped == T]
trip_original
#<-data.frame()
#for (e in unique(bs_trip_res[,emo1])){
#  trip_original<-rbind(trip_original,bs_trip_res[emo1==e][1:16])
#}
trip_bs<-bs_trip_res[is_not_bootstrapped == F]
my_mean <- my_sd <- trip_bs[, lapply(.SD, mean), .SDcols = paste0('has_',emotions), by=c('is_questionable','emo1','emo2')]
my_sd <- trip_bs[, lapply(.SD, sd), .SDcols = paste0('has_',emotions), by=c('is_questionable','emo1','emo2')]
my_mean
my_sd
#Emo2 = 'joy'
#Emo2 = 'anticipation
trip_trim <- data.table()
for(Emo1 in c('',emotions)){
for(Emo2 in emotions){
for (rel in 0:1){
this_row <- trip_original[emo1==Emo1 & emo2==Emo2 & is_questionable == rel, .SD, .SDcols = paste0('has_',emotions) ]
this_mean = my_mean[emo1==Emo1 & emo2==Emo2 & is_questionable == rel,.SD, .SDcols = paste0('has_',emotions) ]
this_sd = my_sd[emo1==Emo1 & emo2==Emo2 & is_questionable == rel, .SD, .SDcols = paste0('has_',emotions) ]
this_thresh <- this_mean + 2*this_sd
this_bool <-  this_row > this_thresh
this_row <- cbind(is_questionable =rel, emo1=Emo1, emo2=Emo2, this_row * this_bool)
trip_trim<-rbindlist(list(trip_trim, this_row))
}
}
}
# how many zeroes are there?
trip_trim[,.SD, .SDcols = paste0('has_',emotions)][,lapply(.SD, function(x) x==0)][,lapply(.SD,sum)][,sum(.SD)]
trip_trim
trip_trim <- data.table()
for(Emo1 in c('',emotions)){
for(Emo2 in emotions){
for (rel in 0:1){
this_row <- trip_original[emo1==Emo1 & emo2==Emo2 & is_questionable == rel, .SD, .SDcols = paste0('has_',emotions) ]
this_mean = my_mean[emo1==Emo1 & emo2==Emo2 & is_questionable == rel,.SD, .SDcols = paste0('has_',emotions) ]
this_sd = my_sd[emo1==Emo1 & emo2==Emo2 & is_questionable == rel, .SD, .SDcols = paste0('has_',emotions) ]
this_thresh <- this_mean + 2*this_sd
this_bool <-  this_row >= this_thresh # only difference from before
this_row <- cbind(is_questionable =rel, emo1=Emo1, emo2=Emo2, this_row * this_bool)
trip_trim<-rbindlist(list(trip_trim, this_row))
}
}
}
# how many zeroes are there?
trip_trim[,.SD, .SDcols = paste0('has_',emotions)][,lapply(.SD, function(x) x==0)][,lapply(.SD,sum)][,sum(.SD)]
source('packages_n_global_variables.R')
source('packages_n_global_variables.R')
source('packages_n_global_variables.R')
emo_csv <- fread(emo_csv_path)
emotions <- emotions[c(6, 5, 2, 8, 7, 4, 1, 3)]
emo_in_comments <- emo_csv[emotiveness>0, .(counts=colSums(.SD), emo=names(.SD)), by=c("Is_questionable", "Label"), .SDcols = paste0('has_',emotions)]
RBT <- data.frame()
for (e in emo_in_comments[,emo]%>%unique()){
curr_query <- emo_csv[get(e) > 0,.(Label = Label%>%str_extract('[0-9]')%>%as.integer(), Is_questionable)]
rank_biserial_test<-wilcoxonRG(x=curr_query[,Label], g = curr_query[,Is_questionable], conf = 0.95, ci=T)
RBT<-rbind(RBT,c(emo=e,rank_biserial_test))
}
setDT(RBT)
RBT[,err.ci := upper.ci-rg]
RBT
saveRDS(RBT, file.path(plot_dir,'rank_biserial_test_comments.rds'))
source('packages_n_global_variables.R')
RBT<-readRDS(file.path(plot_dir,'rank_biserial_test_comments.rds'))
RBT
?wilcoxonRG
rank_biserial_test
source('packages_n_global_variables.R')
# load comments
emo_csv <- fread(emo_csv_path)
# select users in the shapley summary
usr_emo_lean <- fread(usr_emo_lean_path)
usr_emo_lean<-usr_emo_lean[leaning <=.25 | leaning >=.75]
usr_emo_lean<- usr_emo_lean[n_emo>0 & n_comments >=8]
users_in_shapley <- usr_emo_lean[, .(Nome_Utente, id, is_questionable )]
setkey(users_in_shapley, Nome_Utente)
setkey(emo, Nome_Utente)
emo[,is_appropriate:=Label == "0. appropriato"]
emo <- merge(emo,users_in_shapley)
emo <- emo[, is_questionable := NULL]
names(emo)[which(names(emo) == "usr_is_questionable")] = "is_questionable"
comments_emo_in_shapley<-emo[, .SD, .SDcols = c(paste0("has_",emotions), "is_questionable")]
#order emotion name vector by positivity and relevance
emotions <-c("anger", "anticipation", "disgust", "fear", "joy", "trust", "sadness","surprise")
emotions <- emotions[c(6, 5, 2, 8, 7, 4, 1, 3)]
# if emo1 is selected, select comments with emo1 and exclude it from emotional features to aggregate
emo_subset = emotions
if (!is.na(emo1)){
emo_subset = emotions[emotions!=emo1]
data = data[get(paste0("has_",emo1)) == 1]
data[, c(paste0("has_",emo1)):= NULL]
}
data=comments_emo_in_shapley
source('packages_n_global_variables.R')
# load comments
emo_csv <- fread(emo_csv_path)
# select users in the shapley summary
usr_emo_lean <- fread(usr_emo_lean_path)
usr_emo_lean<-usr_emo_lean[leaning <=.25 | leaning >=.75]
usr_emo_lean<- usr_emo_lean[n_emo>0 & n_comments >=8]
users_in_shapley <- usr_emo_lean[, .(Nome_Utente, id, is_questionable )]
usr_emo_lean
source('packages_n_global_variables.R')
emo_csv <- fread(emo_csv_path)
setDT(emo_csv)
# bin_questionable is the integer version of is_questionable
emo_csv[, bin_questionable := is_questionable*1]
# assign lean to users using their Nome_Utente
# lean is #is_questionable/#comments
leanings <- emo_csv[, .(leaning = sum(bin_questionable)/.N),by = Nome_Utente  ]
leanings[, is_questionable := (leaning > 0.25 )]
# set to NA every leaning between .75 and .25
leanings = leanings[leaning<0.75 & leaning >0.25, is_questionable := NA]
# this does not exclude users with undiscernable leaning (between .25 ad .75)
##leanings = leanings[lean>=0.75 | lean <=0.25]
# discretize leaning so that users with lean close to 1 are 1
#setkey(emo_csv, Nome_Utente)
setkey(leanings, Nome_Utente)
toxicity <- emo_csv[,unique(Label)]
# add variable has_emotion = #comments with emotion/#comments
usr_emo <- emo_csv[, .(has_anger = sum(has_anger)/.N,
has_anticipation = sum(has_anticipation)/.N,
has_disgust = sum(has_disgust)/.N,
has_fear = sum(has_fear)/.N,
has_joy = sum(has_joy)/.N,
has_sadness = sum(has_sadness)/.N,
has_surprise = sum(has_surprise)/.N,
has_trust = sum(has_trust)/.N,
n_comments = .N,
n_words = sum(stringr::str_count(Testo ,"\\W+") ),
len_text = sum(length(Testo)),
appropriate = sum(Label == toxicity[1])/.N,
inappropriate = sum(Label == toxicity[2])/.N,
offensive = sum(Label == toxicity[3])/.N,
violent = sum(Label == toxicity[4])/.N
), by = Nome_Utente ]
setkey(usr_emo, Nome_Utente)
# merge emotion and leanings
usr_emo_lean <- merge(usr_emo, leanings)
setnames(usr_emo_lean, paste0("has_", emotions), emotions)
setorder(usr_emo_lean, Nome_Utente)
names(usr_emo_lean)
head(usr_emo_lean)
usr_emo_lean[, id := row_number(Nome_Utente)]
#usr_emo_lean[, Nome_Utente:=NULL]
usr_emo_lean[, n_emo := rowSums(.SD > 0), .SDcols = emotions]
fwrite(usr_emo_lean, file.path(data_dir,"usr_emo_lean.gz"),
logical01 = T,
compress = "gzip",
na = "NA" )
source('packages_n_global_variables.R')
# load comments
emo_csv <- fread(emo_csv_path)
# select users in the shapley summary
usr_emo_lean <- fread(usr_emo_lean_path)
usr_emo_lean<-usr_emo_lean[leaning <=.25 | leaning >=.75]
usr_emo_lean<- usr_emo_lean[n_emo>0 & n_comments >=8]
users_in_shapley <- usr_emo_lean[, .(Nome_Utente, id, is_questionable )]
names(users_in_shapley)<-c("Nome_Utente", "id", "usr_is_questionable")
setkey(users_in_shapley, Nome_Utente)
setkey(emo, Nome_Utente)
emo[,is_appropriate:=Label == "0. appropriato"]
emo <- merge(emo,users_in_shapley)
emo <- emo[, is_questionable := NULL]
names(emo)[which(names(emo) == "usr_is_questionable")] = "is_questionable"
comments_emo_in_shapley<-emo[, .SD, .SDcols = c(paste0("has_",emotions), "is_questionable")]
data=comments_emo_in_shapley
rm(emo_csv)
# load comments
emo <- fread(emo_csv_path)
# select users in the shapley summary
usr_emo_lean <- fread(usr_emo_lean_path)
usr_emo_lean<-usr_emo_lean[leaning <=.25 | leaning >=.75]
usr_emo_lean<- usr_emo_lean[n_emo>0 & n_comments >=8]
users_in_shapley <- usr_emo_lean[, .(Nome_Utente, id, is_questionable )]
names(users_in_shapley)<-c("Nome_Utente", "id", "usr_is_questionable")
setkey(users_in_shapley, Nome_Utente)
setkey(emo, Nome_Utente)
emo[,is_appropriate:=Label == "0. appropriato"]
emo <- merge(emo,users_in_shapley)
emo <- emo[, is_questionable := NULL]
names(emo)[which(names(emo) == "usr_is_questionable")] = "is_questionable"
comments_emo_in_shapley<-emo[, .SD, .SDcols = c(paste0("has_",emotions), "is_questionable")]
data=comments_emo_in_shapley
emo1 = 'trust'
n_bootstrap = 100000
n_clust=parallel::detectCores()
#order emotion name vector by positivity and relevance
emotions <-c("anger", "anticipation", "disgust", "fear", "joy", "trust", "sadness","surprise")
emotions <- emotions[c(6, 5, 2, 8, 7, 4, 1, 3)]
# if emo1 is selected, select comments with emo1 and exclude it from emotional features to aggregate
emo_subset = emotions
if (!is.na(emo1)){
emo_subset = emotions[emotions!=emo1]
data = data[get(paste0("has_",emo1)) == 1]
data[, c(paste0("has_",emo1)):= NULL]
}
# transform comments data into binary features
c_emo_trust_original<-data[, .SD*1, .SDcols = c(paste0("has_",emo_subset),'is_questionable')]
#empty table to be filled
#will contain p( e3 | e1 & e2 & l)
mean_emo <- data.table()
#emo2_subset = emotions
# compute mean, excluding 'emo1'
NN = c_emo_trust_original[,.N, by = is_questionable] # data for number of comments by reliability
NN
i = 1
emo2 = emotions[i]
emo2
i = 2
emo2 = emotions[i]
emo2
if((!is.na(emo1) & emo1!=emo2)|is.na(emo1)){
temp_emo <- c_emo_trust_original[get(paste0('has_',emo2)) >0]#select comments with emo2
}else {
temp_emo <- c_emo_trust_original
}
n_emo2 <-temp_emo[, .N, by=is_questionable]
n_emo2
reliability_col <- temp_emo[,is_questionable]
temp_emo
temp_emo <- temp_emo[,.SD*1 ]
temp_emo
if(!is.na(emo1) & emo1!=emo2){
temp_emo[, (paste0('has_',emo2)):=NULL]
}
n_emo2
reliability_col
#when computing p(e2 & e3 | e1, l)
if((!is.na(emo1) & emo1!=emo2)|is.na(emo1)){
temp_emo <- c_emo_trust_original[get(paste0('has_',emo2)) >0]#select comments with emo2
}else { #when computing p(e2 | e1, l) or #when computing p(e2 & e3 | l)
temp_emo <- c_emo_trust_original # select everything
}
n_emo2 <-temp_emo[, .N, by=is_questionable]
reliability_col <- temp_emo[,is_questionable] # row of reliabilities to be attached later
temp_emo <- temp_emo[,.SD*1 ]
if(!is.na(emo1) & emo1!=emo2){
temp_emo[, (paste0('has_',emo2)):=NULL]
}
temp_emo<-temp_emo[, lapply(.SD,sum ), .SDcols = paste0('has_',emo_subset[emo_subset!=emo2]), by=is_questionable]
temp_emo
#
names(n_emo2)[which(names(n_emo2)=='N')] <-paste0('has_',emo2)
temp_emo
temp_emo <- temp_emo[, lapply(.SD,sum ), .SDcols = paste0('has_',emo_subset[emo_subset!=emo2]), by=is_questionable]
temp_emo
#when computing p(e2 & e3 | e1, l)
if((!is.na(emo1) & emo1!=emo2)|is.na(emo1)){
temp_emo <- c_emo_trust_original[get(paste0('has_',emo2)) >0]#select comments with emo2
}else { #when computing p(e2 | e1, l) or #when computing p(e2 & e3 | l)
temp_emo <- c_emo_trust_original # select everything
}
n_emo2 <-temp_emo[, .N, by=is_questionable]
reliability_col <- temp_emo[,is_questionable] # row of reliabilities to be attached later
temp_emo <- temp_emo[,.SD*1 ]
if(!is.na(emo1) & emo1!=emo2){
temp_emo[, (paste0('has_',emo2)):=NULL]
}
# count comments with e2 and e3 containing each emotion
temp_emo<-temp_emo[, lapply(.SD,sum ), .SDcols = paste0('has_',emo_subset[emo_subset!=emo2]), by=is_questionable]
temp_emo
temp_emo <- temp_emo[, lapply(.SD,sum ), .SDcols = paste0('has_',emo_subset[emo_subset!=emo2]), by=is_questionable]
temp_emo
setkey(temp_emo, is_questionable)
setkey(n_emo2, is_questionable)
setkey(NN, is_questionable)
temp_emo <- merge(temp_emo, n_emo2)
temp_emo
temp_emo<-merge(temp_emo, NN)
temp_emo
#when computing p(e2 & e3 | e1, l)
if((!is.na(emo1) & emo1!=emo2)|is.na(emo1)){
temp_emo <- c_emo_trust_original[get(paste0('has_',emo2)) >0]#select comments with emo2
}else { #when computing p(e2 | e1, l) or #when computing p(e2 & e3 | l)
temp_emo <- c_emo_trust_original # select everything
}
n_emo2 <-temp_emo[, .N, by=is_questionable]
reliability_col <- temp_emo[,is_questionable] # row of reliabilities to be attached later
temp_emo <- temp_emo[,.SD*1 ]
if(!is.na(emo1) & emo1!=emo2){
temp_emo[, (paste0('has_',emo2)):=NULL]
}
# count comments with e2 and e3 containing each emotion
temp_emo<-temp_emo[, lapply(.SD,sum ), .SDcols = paste0('has_',emo_subset[emo_subset!=emo2]), by=is_questionable]
#add information on total numbers
setkey(temp_emo, is_questionable)
setkey(n_emo2, is_questionable)
setkey(NN, is_questionable)
temp_emo <- merge(temp_emo, n_emo2)
temp_emo
n_emo2
names(n_emo2)[which(names(n_emo2)=='N')] <-paste0('has_',emo2)
temp_emo
temp_emo<-merge(temp_emo, NN)
temp_emo
#when computing p(e2 & e3 | e1, l)
if((!is.na(emo1) & emo1!=emo2)|is.na(emo1)){
temp_emo <- c_emo_trust_original[get(paste0('has_',emo2)) >0]#select comments with emo2
}else { #when computing p(e2 | e1, l) or #when computing p(e2 & e3 | l)
temp_emo <- c_emo_trust_original # select everything
}
n_emo2 <-temp_emo[, .N, by=is_questionable]
reliability_col <- temp_emo[,is_questionable] # row of reliabilities to be attached later
temp_emo <- temp_emo[,.SD*1 ]
if(!is.na(emo1) & emo1!=emo2){
temp_emo[, (paste0('has_',emo2)):=NULL]
}
# count comments with e2 and e3 containing each emotion
temp_emo<-temp_emo[, lapply(.SD,sum ), .SDcols = paste0('has_',emo_subset[emo_subset!=emo2]), by=is_questionable]
#add information on total numbers
setkey(temp_emo, is_questionable)
setkey(n_emo2, is_questionable)
setkey(NN, is_questionable)
temp_emo <- merge(temp_emo, n_emo2)
names(n_emo2)[which(names(n_emo2)=='N')] <-paste0('has_',emo2)
#when computing p(e2 & e3 | e1, l)
if((!is.na(emo1) & emo1!=emo2)|is.na(emo1)){
temp_emo <- c_emo_trust_original[get(paste0('has_',emo2)) >0]#select comments with emo2
}else { #when computing p(e2 | e1, l) or #when computing p(e2 & e3 | l)
temp_emo <- c_emo_trust_original # select everything
}
n_emo2 <-temp_emo[, .N, by=is_questionable]
reliability_col <- temp_emo[,is_questionable] # row of reliabilities to be attached later
temp_emo <- temp_emo[,.SD*1 ]
if(!is.na(emo1) & emo1!=emo2){
temp_emo[, (paste0('has_',emo2)):=NULL]
}
# count comments with e2 and e3 containing each emotion
temp_emo<-temp_emo[, lapply(.SD,sum ), .SDcols = paste0('has_',emo_subset[emo_subset!=emo2]), by=is_questionable]
#add information on total numbers
setkey(temp_emo, is_questionable)
setkey(n_emo2, is_questionable)
setkey(NN, is_questionable)
names(n_emo2)[which(names(n_emo2)=='N')] <-paste0('has_',emo2)
temp_emo <- merge(temp_emo, n_emo2)
temp_emo
temp_emo<-merge(temp_emo, NN)
temp_emo
temp_emo<-temp_emo[, lapply(.SD, '/', N), by=is_questionable][,N:=NULL]
if (!is.na(emo1)){
temp_emo[,(paste0('has_', emo1)):=1 ]
}
temp_emo
temp_emo[,is_not_bootstrapped := TRUE]
temp_emo
temp_emo[,emo2:=emo2]
setcolorder(temp_emo, c('emo2', 'is_questionable', paste0('has_', emotions) ))
mean_emo <- rbindlist(list(mean_emo, temp_emo), use.names = sum(dim(mean_emo))>0)
mean_emo
NN
mean_emo
reliability_col <- c_emo_trust_original[,is_questionable]
reliability_col
M_emo
#create matrix to shuffle data later
M_emo<-c_emo_trust_original[,.SD*1 #transform data into binary
][, is_questionable:=NULL]%>% # exclude reliability column
t() # convert to matrix and transpose
M_emo
M_emo%>%head()
M_emo%>%t()%>%head()
# start parallel computation
rm(temp_emo)
M_emo
M_emo%>%as.integer
ncol(M_emo)
temp_res
source('packages_n_global_variables.R')
emo_triplets_in_shapley_users <- fread(file.path(data_dir, "emo_triplets_in_shapley_users_comments.tsv"),sep='\t'))
emo_triplets_in_shapley_users <- fread(file.path(data_dir, "emo_triplets_in_shapley_users_comments.tsv"),sep='\t')
data_dir
emo_triplets_in_shapley_users <- fread(file.path(data_dir, "emo_triplets_in_shapley_users_comments.tsv"))
